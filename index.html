<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>あるごん・クエスト</title>
  <style>
    /* 全体のスタイル設定 */
    body {
      background-color: #e0f7fa;
      font-family: "Hiragino Kaku Gothic ProN", "メイリオ", sans-serif;
      color: #004d40;
      margin: 0;
      user-select: none; /* テキスト選択の無効化 */
      overflow: hidden; /* スクロールバーを隠す */
    }

    .screen {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      width: 100vw; height: 100vh; position: absolute; top: 0; left: 0;
      transition: opacity 0.5s, visibility 0.5s;
    }
    .screen.hidden {
      visibility: hidden; opacity: 0; pointer-events: none;
    }

    /* --- タイトル画面 --- */
    #title-screen h1 { font-size: 5em; text-shadow: 3px 3px 0 #00796b; margin-bottom: 50px; }
    #title-buttons { display: flex; gap: 20px; }
    .title-button {
      font-size: 2em; font-weight: bold; padding: 15px 60px; border: none;
      border-radius: 15px; color: #004d40;
      box-shadow: 0 8px #f57c00; cursor: pointer; transition: all 0.1s;
    }
    .title-button:active { transform: translateY(8px); box-shadow: none; }
    #start-button { background-color: #ffc107; }
    #tutorial-button { background-color: #81d4fa; font-size: 1.5em; padding: 10px 40px; box-shadow: 0 6px #0288d1;}
    #tutorial-button:active { transform: translateY(6px); box-shadow: none; }


    /* --- ステージ選択画面 --- */
    #stage-select-screen h2 { font-size: 3em; margin-bottom: 20px; }
    #stage-grid-container {
      width: 740px; 
      height: 420px;
      overflow-y: auto;
      padding: 20px;
      background-color: rgba(255,255,255,0.5);
      border-radius: 10px;
      margin-bottom: 20px;
    }
    #stage-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 20px; }
    .stage-button {
      width: 120px; height: 120px; background-color: #ffffff; border: 5px solid #00796b;
      border-radius: 15px; font-weight: bold; color: #004d40;
      cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .stage-button:not(:disabled):hover { background-color: #c8e6c9; transform: translateY(-5px); }
    .stage-button:disabled { background-color: #bdbdbd; border-color: #616161; color: #757575; cursor: not-allowed; font-size: 3em; }
    .stage-number { font-size: 2.5em; line-height: 1.2; }
    .star-rating { font-size: 1.2em; letter-spacing: 2px; }
    .star-yellow { color: #ffeb3b; }
    .star-gray { color: #ccc; }
    .back-button { font-size: 1.2em; padding: 10px 30px; background-color: #90a4ae; color: white; border: none; border-radius: 10px; cursor: pointer; }

    /* --- ゲーム画面 --- */
    #game-screen h1 { font-size: 2.5em; margin: 20px 0; }
    #game-wrapper { display: flex; gap: 20px; margin-bottom: 20px; align-items: flex-start; }
    #stage { width: 450px; height: 450px; background-color: #ffffff; border: 5px solid #00796b; background-size: 90px 90px; background-image: repeating-linear-gradient(to right, #ddd, #ddd 1px, transparent 1px, transparent 90px), repeating-linear-gradient(to bottom, #ddd, #ddd 1px, transparent 1px, transparent 90px); position: relative; }
    
    #algon {
      position: absolute;
      width: 81px;
      height: 81px;
      transition: all 0.3s ease; /* 移動のスムーズさ */
      z-index: 10;
    }
    .algon-body {
      width: 100%;
      height: 100%;
      background-color: #42a5f5;
      border-radius: 12px;
      position: relative; /* 目の基準位置 */
      animation: breathing 2.5s ease-in-out infinite;
    }
    @keyframes breathing {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    .algon-body::before, .algon-body::after {
      content: ''; position: absolute; width: 12px; height: 18px;
      background-color: #ffee58; border-radius: 50%; border: 4px solid #333; top: 12px; 
      animation: blink 4s infinite;
    }
    .algon-body::before { left: 15px; }
    .algon-body::after { right: 15px; animation-delay: 0.1s; }

    @keyframes blink {
      0%, 95%, 100% {
        transform: scaleY(1);
      }
      97.5% {
        transform: scaleY(0.1);
      }
    }
    
    #goal { position: absolute; width: 88px; height: 88px; font-size: 68px; text-align: center; line-height: 88px; color: #ffeb3b; z-index: 5;}
    .wall { position: absolute; width: 88px; height: 88px; background-color: #a1887f; border: 1px solid #5d4037; box-sizing: border-box; z-index: 5; background-size: calc(88px / 3) calc(88px / 3); background-image: linear-gradient(to right, #5d4037 1px, transparent 1px), linear-gradient(to bottom, #5d4037 1px, transparent 1px); }
    #programming-area { width: 300px; height: 450px; background-color: #b2dfdb; border: 5px solid #00796b; display: flex; flex-direction: column; align-items: center; gap: 5px; padding-top: 10px; overflow-y: auto; }
    #block-palette { width: 240px; height: 450px; padding: 10px; background-color: #e0e0e0; border-radius: 5px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .block { width: 200px; padding: 10px 15px; border-radius: 5px; font-weight: bold; cursor: grab; flex-shrink: 0; display: flex; align-items: center; justify-content: flex-start; gap: 8px; position: relative; transition: opacity 0.2s; }
    .block-icon { font-size: 1.5em; line-height: 1; }
    .block-label { flex-grow: 1; }
    .block-input-wrapper { display: flex; align-items: center; }
    .repeat-input { width: 35px; height: 30px; font-size: 1em; font-weight: bold; text-align: center; border: 1px solid #555; border-radius: 4px; background-color: #ffffff; color: #004d40; margin: 0 4px; }
    .block-turn-right .block-icon { transform: rotate(15deg); }
    .block-turn-left .block-icon { transform: rotate(-15deg); }
    .block-forward { background-color: #81d4fa; border: 2px solid #0288d1; }
    .block-backward { background-color: #ffcc80; border: 2px solid #ef6c00; }
    .block-turn-right { background-color: #ce93d8; border: 2px solid #7b1fa2; }
    .block-turn-left { background-color: #a5d6a7; border: 2px solid #388e3c; }
    .dragging { cursor: grabbing !important; opacity: 0.5; }
    .drop-indicator { width: 100%; height: 4px; background: #0288d1; margin: 2px 0; flex-shrink: 0; }
    #controls { display: flex; gap: 20px; }
    .control-button { font-size: 1.5em; font-weight: bold; padding: 10px 40px; border: none; border-radius: 10px; color: #004d40; cursor: pointer; transition: all 0.1s; }
    #run-button { background-color: #ffc107; box-shadow: 0 5px #f57c00; }
    #run-button:active { transform: translateY(5px); box-shadow: none; }
    #reset-button { background-color: #ef5350; box-shadow: 0 5px #d32f2f; }
    #reset-button:active { transform: translateY(5px); box-shadow: none; }
    
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; visibility: hidden; opacity: 0; transition: all 0.3s; }
    .modal-overlay.visible { visibility: visible; opacity: 1; }
    .modal-content { background-color: white; padding: 20px 40px; border-radius: 15px; text-align: center; }
    #modal-message { font-size: 2.5em; font-weight: bold; margin-bottom: 10px; }
    #modal-stars { font-size: 2em; letter-spacing: 5px; height: 40px; }
    #modal-content.success #modal-message { color: #ff9800; }
    #modal-content.fail #modal-message { color: #d32f2f; }

    #tutorial-content {
      padding: 30px;
      max-width: 800px;
    }
    #tutorial-content h2 { font-size: 2.5em; margin-top: 0; }
    #tutorial-content p { font-size: 1.5em; line-height: 1.6; white-space: pre-wrap; text-align: left; }
    #tutorial-close-button {
      font-size: 1.5em; font-weight: bold; padding: 10px 50px; margin-top: 20px;
      border: none; border-radius: 10px; color: #004d40; background-color: #ffc107;
      box-shadow: 0 5px #f57c00; cursor: pointer; transition: all 0.1s;
    }
    #tutorial-close-button:active { transform: translateY(5px); box-shadow: none; }
  </style>
</head>
<body>

  <div id="title-screen" class="screen">
    <h1>あるごん・クエスト</h1>
    <div id="title-buttons">
      <button id="start-button" class="title-button">スタート！</button>
      <button id="tutorial-button" class="title-button">あそびかた</button>
    </div>
  </div>

  <div id="stage-select-screen" class="screen hidden">
    <h2>ステージを えらんでね</h2>
    <div id="stage-grid-container">
      <div id="stage-grid"></div>
    </div>
    <button id="back-to-title-button" class="back-button">タイトルにもどる</button>
  </div>
  
  <div id="game-screen" class="screen hidden">
    <h1 id="game-stage-title"></h1>
    <div id="game-wrapper">
      <div id="stage">
        <div id="algon">
          <div class="algon-body"></div>
        </div>
        <div id="goal">★</div>
      </div>
      <div id="programming-area"></div>
      <div id="block-palette">
        <div class="block block-forward" data-command="forward" draggable="true"><span class="block-icon">↑</span><span class="block-label">まえ</span><span class="block-input-wrapper"><input type="text" inputmode="numeric" pattern="[0-9]*" class="repeat-input"><span>かい</span></span></div>
        <div class="block block-backward" data-command="backward" draggable="true"><span class="block-icon">↓</span><span class="block-label">うしろ</span><span class="block-input-wrapper"><input type="text" inputmode="numeric" pattern="[0-9]*" class="repeat-input"><span>かい</span></span></div>
        <div class="block block-turn-right" data-command="turnRight" draggable="true"><span class="block-icon">↻</span><span class="block-label">みぎに</span><span class="block-input-wrapper"><input type="text" inputmode="numeric" pattern="[0-9]*" class="repeat-input"><span>かい</span></span></div>
        <div class="block block-turn-left" data-command="turnLeft" draggable="true"><span class="block-icon">↺</span><span class="block-label">ひだりに</span><span class="block-input-wrapper"><input type="text" inputmode="numeric" pattern="[0-9]*" class="repeat-input"><span>かい</span></span></div>
      </div>
    </div>
    <div id="controls">
      <button id="run-button" class="control-button">じっこう！</button>
      <button id="reset-button" class="control-button">やりなおし</button>
      <button id="back-to-select-button" class="back-button">ステージにもどる</button>
    </div>
  </div>

  <div id="modal-overlay" class="modal-overlay">
    <div id="modal-content" class="modal-content">
      <p id="modal-message"></p>
      <div id="modal-stars"></div>
    </div>
  </div>

  <div id="tutorial-overlay" class="modal-overlay">
    <div id="tutorial-content" class="modal-content">
      <h2 id="tutorial-title"></h2>
      <p id="tutorial-text"></p>
      <button id="tutorial-close-button">わかった！</button>
    </div>
  </div>

  <script>
    const screens = { title: document.getElementById('title-screen'), stageSelect: document.getElementById('stage-select-screen'), game: document.getElementById('game-screen') };
    const startButton = document.getElementById('start-button');
    const tutorialButton = document.getElementById('tutorial-button');
    const stageGrid = document.getElementById('stage-grid');
    const backToTitleButton = document.getElementById('back-to-title-button');
    const backToSelectButton = document.getElementById('back-to-select-button');
    const gameStageTitle = document.getElementById('game-stage-title');
    const stage = document.getElementById('stage');
    const algon = document.getElementById('algon');
    const goal = document.getElementById('goal');
    const programmingArea = document.getElementById('programming-area');
    const paletteBlocks = document.querySelectorAll('#block-palette .block');
    const runButton = document.getElementById('run-button');
    const resetButton = document.getElementById('reset-button');
    const modalOverlay = document.getElementById('modal-overlay');
    const tutorialOverlay = document.getElementById('tutorial-overlay');
    const tutorialCloseButton = document.getElementById('tutorial-close-button');

    const CELL_SIZE = 90;
    // ▼▼▼ ステージ設計図を全20ステージに修正 ▼▼▼
    const stages = [
      { id: 1, bestScore: 1, start: { x: 4, y: 4, dir: 1 }, goal: { x: 184, y: 4 }, 
        walls: [ {x:0, y:1}, {x:1, y:1}, {x:2, y:1}, {x:3, y:1}, {x:4, y:1}, {x:0, y:2}, {x:1, y:2}, {x:2, y:2}, {x:3, y:2}, {x:4, y:2}, {x:0, y:3}, {x:1, y:3}, {x:2, y:3}, {x:3, y:3}, {x:4, y:3}, {x:0, y:4}, {x:1, y:4}, {x:2, y:4}, {x:3, y:4}, {x:4, y:4}, ],
        tutorial: { title: "あそびかた", text: "① みぎのブロックを まんなかのエリアに\nドラッグ＆ドロップで もっていこう！\n\n②「じっこう！」ボタンをおすと、\nあるごんが うごきだすよ！" }
      },
      { id: 2, bestScore: 1, start: { x: 4, y: 4, dir: 1 }, goal: { x: 364, y: 4 }, 
        walls: [ {x:0, y:1}, {x:1, y:1}, {x:2, y:1}, {x:3, y:1}, {x:4, y:1}, {x:0, y:2}, {x:1, y:2}, {x:2, y:2}, {x:3, y:2}, {x:4, y:2}, {x:0, y:3}, {x:1, y:3}, {x:2, y:3}, {x:3, y:3}, {x:4, y:3}, {x:0, y:4}, {x:1, y:4}, {x:2, y:4}, {x:3, y:4}, {x:4, y:4}, ],
        tutorial: { title: "かずを いれてみよう！", text: "ブロックの しかくいマスに すうじをいれると、\nその かずだけ うごきを くりかえすよ！\n\n『まえに 4かい』やってみよう！" }
      },
      { id: 3, bestScore: 1, start: { x: 4, y: 364, dir: 0 }, goal: { x: 4, y: 4 }, walls: [ {x:1, y:0}, {x:1, y:1}, {x:1, y:2}, {x:1, y:3}, {x:1, y:4}, {x:2, y:0}, {x:2, y:1}, {x:2, y:2}, {x:2, y:3}, {x:2, y:4}, {x:3, y:0}, {x:3, y:1}, {x:3, y:2}, {x:3, y:3}, {x:3, y:4}, {x:4, y:0}, {x:4, y:1}, {x:4, y:2}, {x:4, y:3}, {x:4, y:4}, ] },
      { id: 4, bestScore: 3, start: { x: 4, y: 364, dir: 0 }, goal: { x: 364, y: 4 }, walls: [ {x:1,y:1},{x:1,y:2},{x:1,y:3},{x:1,y:4}, {x:2,y:1},{x:2,y:2},{x:2,y:3},{x:2,y:4}, {x:3,y:1},{x:3,y:2},{x:3,y:3},{x:3,y:4}, {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4}, ] },
      { id: 5, bestScore: 3, start: { x: 4, y: 4, dir: 1 }, goal: { x: 364, y: 364 }, walls: [ {x:0,y:1},{x:1,y:1},{x:2,y:1},{x:3,y:1}, {x:0,y:2},{x:1,y:2},{x:2,y:2},{x:3,y:2}, {x:0,y:3},{x:1,y:3},{x:2,y:3},{x:3,y:3}, {x:0,y:4},{x:1,y:4},{x:2,y:4},{x:3,y:4}, ] },
      { id: 6, bestScore: 3, start: { x: 4, y: 4, dir: 2 }, goal: { x: 4, y: 274 }, 
        walls: [{x:1,y:1},{x:2,y:1},{x:3,y:1},{x:4,y:1}],
        tutorial: { title: "むきを かえてみよう！", text: "『みぎに』や『ひだりに』ブロックをつかうと、\nあるごんの むきが かわるよ。\n\nうまく つかって ゴールを めざそう！" }
      },
      { id: 7, bestScore: 4, start: { x: 4, y: 4, dir: 1 }, goal: { x: 4, y: 364 }, walls: [{x:1,y:0},{x:1,y:1},{x:1,y:2},{x:1,y:3}] },
      { id: 8, bestScore: 3, start: { x: 184, y: 364, dir: 0 }, goal: { x: 4, y: 4 }, walls: [{x:1,y:2},{x:3,y:2},{x:4,y:2}] },
      { id: 9, bestScore: 5, start: { x: 4, y: 184, dir: 1 }, goal: { x: 364, y: 184 }, walls: [{x:2,y:0},{x:2,y:1},{x:2,y:3},{x:2,y:4}] },
      { id: 10, bestScore: 5, start: { x: 4, y: 4, dir: 1 }, goal: { x: 364, y: 364 }, walls: [ {x:1,y:0},{x:1,y:1},{x:1,y:2},{x:1,y:3}, {x:3,y:1},{x:3,y:2},{x:3,y:3},{x:3,y:4} ] },
      { id: 11, bestScore: 4, start: { x: 4, y: 4, dir: 2 }, goal: { x: 184, y: 94 }, walls: [{x:1,y:0},{x:1,y:1},{x:2,y:2},{x:3,y:2},{x:3,y:1}] },
      { id: 12, bestScore: 7, start: { x: 4, y: 4, dir: 2 }, goal: { x: 274, y: 184 }, walls: [{x:1,y:1},{x:3,y:1},{x:4,y:1}, {x:2,y:2}, {x:0,y:3},{x:3,y:3}] },
      { id: 13, bestScore: 4, start: { x: 184, y: 184, dir: 1 }, goal: { x: 184, y: 184 }, walls: [ {x:3,y:2},{x:2,y:1},{x:1,y:2},{x:2,y:3} ] },
      { id: 14, bestScore: 5, start: { x: 364, y: 364, dir: 0 }, goal: { x: 4, y: 4 }, walls: [{x:1,y:1},{x:1,y:2},{x:1,y:3}, {x:3,y:1},{x:3,y:2},{x:3,y:3}] },
      { id: 15, bestScore: 5, start: { x: 4, y: 4, dir: 1 }, goal: { x: 4, y: 4 }, walls: [{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3},{x:1,y:4},{x:2,y:4},{x:3,y:4},{x:4,y:4},{x:4,y:3},{x:4,y:2},{x:4,y:1}] },
      { id: 16, bestScore: 4, start: { x: 4, y: 274, dir: 0 }, goal: { x: 364, y: 4 }, walls: [ {x:1,y:0},{x:1,y:1},{x:1,y:2}, {x:3,y:2},{x:3,y:3},{x:3,y:4}] },
      { id: 17, bestScore: 6, start: { x: 4, y: 4, dir: 2 }, goal: { x: 364, y: 364 }, walls: [ {x:1,y:0},{x:1,y:1},{x:1,y:2}, {x:3,y:4},{x:3,y:3},{x:3,y:2} ] },
      { id: 18, bestScore: 6, start: { x: 4, y: 4, dir: 2 }, goal: { x: 364, y: 364 }, walls: [{x:1,y:1},{x:2,y:1},{x:3,y:1}, {x:1,y:3},{x:2,y:3},{x:3,y:3}] },
      { id: 19, bestScore: 5, start: { x: 364, y: 184, dir: 3}, goal: { x: 4, y: 184}, walls: [{x:2,y:0},{x:1,y:2},{x:3,y:2},{x:2,y:3},{x:2,y:4}]},
      { id: 20, bestScore: 4, start: { x: 4, y: 4, dir: 1 }, goal: { x: 184, y: 4 }, walls: [{x:1,y:0},{x:1,y:1},{x:1,y:2},{x:1,y:3}] },
    ];
    // 基本的な遊び方
    const basicTutorial = { title: "あそびかた", text: "① みぎのブロックを まんなかのエリアに\nドラッグ＆ドロップで もっていこう！\n\n②「じっこう！」ボタンをおすと、\nあるごんが うごきだすよ！\n\n③ まちがえたブロックは、エリアのそとに\nドラッグ＆ドロップすると けせるよ！" };

    let currentStageData = null;
    let algonX, algonY, algonDirection;
    let currentlyDragged = null;
    let successfullyDropped = false; 
    let isFromProgrammingArea = false; 

    // --- ドラッグ＆ドロップ関連 ---
    function zenkakuToHankaku(str) { return str.replace(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/[^0-9]/g, ''); }
    function applyDragAndDrop(element) { element.draggable = true; element.addEventListener('dragstart', handleDragStart, false); element.addEventListener('dragend', handleDragEnd, false); const input = element.querySelector('.repeat-input'); if (input) { input.addEventListener('mousedown', e => e.stopPropagation()); input.addEventListener('input', e => { e.target.value = zenkakuToHankaku(e.target.value); }); } }
    paletteBlocks.forEach(applyDragAndDrop);
    function handleDragStart(e) { currentlyDragged = e.target; successfullyDropped = false; isFromProgrammingArea = programmingArea.contains(currentlyDragged); setTimeout(() => e.target.classList.add('dragging'), 0); }
    function handleDragEnd() { if (currentlyDragged) { if (isFromProgrammingArea && !successfullyDropped) { currentlyDragged.remove(); } else { currentlyDragged.classList.remove('dragging'); } } removeIndicator(); currentlyDragged = null; }
    programmingArea.addEventListener('dragover', e => { e.preventDefault(); const afterElement = getDragAfterElement(e.clientY); const indicator = getOrCreateIndicator(); if (afterElement == null) { programmingArea.appendChild(indicator); } else { programmingArea.insertBefore(indicator, afterElement); } });
    programmingArea.addEventListener('dragleave', e => { if (e.relatedTarget && !programmingArea.contains(e.relatedTarget)) { removeIndicator(); } });
    programmingArea.addEventListener('drop', e => { e.preventDefault(); if (!currentlyDragged) return; successfullyDropped = true; const isFromPalette = !programmingArea.contains(currentlyDragged); const blockToDrop = isFromPalette ? currentlyDragged.cloneNode(true) : currentlyDragged; if (isFromPalette) { applyDragAndDrop(blockToDrop); } blockToDrop.classList.remove('dragging'); const indicator = programmingArea.querySelector('.drop-indicator'); if (indicator) { programmingArea.insertBefore(blockToDrop, indicator); } else { programmingArea.appendChild(blockToDrop); } removeIndicator(); });
    function getOrCreateIndicator() { let indicator = programmingArea.querySelector('.drop-indicator'); if (!indicator) { indicator = document.createElement('div'); indicator.className = 'drop-indicator'; } return indicator; }
    function removeIndicator() { const indicator = programmingArea.querySelector('.drop-indicator'); if (indicator) indicator.remove(); }
    function getDragAfterElement(y) { const draggableElements = [...programmingArea.querySelectorAll('.block:not(.dragging)')]; return draggableElements.reduce((closest, child) => { const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2; if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } else { return closest; } }, { offset: Number.NEGATIVE_INFINITY }).element; }
    
    // --- 画面切り替え & ステージ選択 ---
    function showScreen(screenName) { for (const key in screens) { screens[key].classList.add('hidden'); } screens[screenName].classList.remove('hidden'); }
    
    // ▼▼▼ ステージロックを有効化 ▼▼▼
    function populateStageSelect() {
      const unlockedStage = parseInt(localStorage.getItem('algonQuestUnlockedStage') || '1');
      const scores = JSON.parse(localStorage.getItem('algonQuestScores') || '{}');
      stageGrid.innerHTML = '';
      
      stages.forEach(stage => {
        const button = document.createElement('button');
        button.className = 'stage-button';
        
        if (stage.id <= unlockedStage) {
          const stageNum = document.createElement('div');
          stageNum.className = 'stage-number';
          stageNum.textContent = stage.id;
          const starRating = document.createElement('div');
          starRating.className = 'star-rating';
          const score = scores[stage.id] || 0;
          starRating.innerHTML = '<span class="star-yellow">★</span>'.repeat(score) + '<span class="star-gray">★</span>'.repeat(3 - score);
          button.appendChild(stageNum);
          button.appendChild(starRating);
          button.addEventListener('click', () => { currentStageData = stage; setupStage(); showScreen('game'); });
        } else {
          button.innerHTML = '🔒';
          button.disabled = true;
        }
        stageGrid.appendChild(button);
      });
    }

    startButton.addEventListener('click', () => showScreen('stageSelect'));
    backToTitleButton.addEventListener('click', () => showScreen('title'));
    backToSelectButton.addEventListener('click', () => showScreen('stageSelect'));

    // --- ゲームの主要な関数 ---
    function setupStage() {
      if (!currentStageData) return;
      document.querySelectorAll('.wall').forEach(wall => wall.remove());
      if (currentStageData.walls) {
        currentStageData.walls.forEach(wallPos => {
          const wallEl = document.createElement('div');
          wallEl.className = 'wall';
          wallEl.style.left = (wallPos.x * CELL_SIZE + 1) + 'px';
          wallEl.style.top = (wallPos.y * CELL_SIZE + 1) + 'px';
          stage.appendChild(wallEl);
        });
      }
      gameStageTitle.textContent = `ステージ ${currentStageData.id}`;
      algonX = currentStageData.start.x; algonY = currentStageData.start.y; algonDirection = currentStageData.start.dir;
      updateAlgonPosition();
      goal.style.left = currentStageData.goal.x + 'px'; goal.style.top = currentStageData.goal.y + 'px';
      programmingArea.innerHTML = '';
      runButton.disabled = false; resetButton.disabled = false;

      if(currentStageData.tutorial){
        showTutorial(currentStageData.tutorial);
      }
    }
    function updateAlgonPosition() { algon.style.left = algonX + 'px'; algon.style.top = algonY + 'px'; algon.style.transform = `rotate(${algonDirection * 90}deg)`; }
    async function executeCommands() { const commands = programmingArea.querySelectorAll('.block'); const blockCount = commands.length; for (const commandBlock of commands) { const command = commandBlock.dataset.command; const input = commandBlock.querySelector('.repeat-input'); const repeatCount = input ? parseInt(input.value, 10) || 1 : 1; for (let i = 0; i < repeatCount; i++) { let hasMoved = false; let tempX = algonX; let tempY = algonY; if (command === 'forward') { if (algonDirection === 0) tempY -= CELL_SIZE; else if (algonDirection === 1) tempX += CELL_SIZE; else if (algonDirection === 2) tempY += CELL_SIZE; else if (algonDirection === 3) tempX -= CELL_SIZE; hasMoved = true; } else if (command === 'backward') { if (algonDirection === 0) tempY += CELL_SIZE; else if (algonDirection === 1) tempX -= CELL_SIZE; else if (algonDirection === 2) tempY -= CELL_SIZE; else if (algonDirection === 3) tempX += CELL_SIZE; hasMoved = true; } else if (command === 'turnRight') { algonDirection = (algonDirection + 1) % 4; } else if (command === 'turnLeft') { algonDirection = (algonDirection + 3) % 4; } if (hasMoved) { const min = 4, max = 364; let collision = false; if (currentStageData.walls) { for (const wall of currentStageData.walls) { const wallX = wall.x * CELL_SIZE + 1; const wallY = wall.y * CELL_SIZE + 1; if (tempX - 3 <= wallX && tempX + 3 >= wallX && tempY - 3 <= wallY && tempY + 3 >= wallY) { collision = true; break; } } } if (tempX < min || tempX > max || tempY < min || tempY > max || collision) { showModal('かべに ぶつかった！', 'fail'); return { status: 'fail' }; } algonX = tempX; algonY = tempY; } updateAlgonPosition(); await new Promise(resolve => setTimeout(resolve, 500)); } } if (algonX === currentStageData.goal.x && algonY === currentStageData.goal.y) { showModal('ステージクリア！', 'success', { blockCount: blockCount }); return { status: 'success', stageId: currentStageData.id, blockCount: blockCount }; } return { status: 'finished' }; }
    runButton.addEventListener('click', async () => {
      if (!currentStageData) return;
      runButton.disabled = true; resetButton.disabled = true;
      algonX = currentStageData.start.x; algonY = currentStageData.start.y; algonDirection = currentStageData.start.dir;
      updateAlgonPosition();
      await new Promise(resolve => setTimeout(resolve, 300));
      const result = await executeCommands();
      if (result.status === 'success') {
        const unlockedStage = parseInt(localStorage.getItem('algonQuestUnlockedStage') || '1');
        const nextStageId = result.stageId + 1;
        if (nextStageId > unlockedStage && nextStageId <= stages.length) { localStorage.setItem('algonQuestUnlockedStage', nextStageId); }
        const scores = JSON.parse(localStorage.getItem('algonQuestScores') || '{}');
        const currentBest = scores[result.stageId] || 0;
        let newScore = 1;
        if (result.blockCount <= currentStageData.bestScore) { newScore = 3; } else if (result.blockCount <= currentStageData.bestScore + 2) { newScore = 2; }
        if (newScore > currentBest) { scores[result.stageId] = newScore; localStorage.setItem('algonQuestScores', JSON.stringify(scores)); }
      } else if (result.status === 'finished') {
        runButton.disabled = false; resetButton.disabled = false;
      }
    });
    resetButton.addEventListener('click', setupStage);
    function showModal(message, type, data = {}) {
      modalOverlay.dataset.resultType = type;
      document.getElementById('modal-message').innerText = message;
      document.getElementById('modal-content').className = 'modal-content';
      const modalStars = document.getElementById('modal-stars');
      if (type === 'success') {
        document.getElementById('modal-content').classList.add('success');
        let newScore = 1;
        if (data.blockCount <= currentStageData.bestScore) { newScore = 3; } else if (data.blockCount <= currentStageData.bestScore + 2) { newScore = 2; }
        modalStars.innerHTML = '<span class="star-yellow">★</span>'.repeat(newScore) + '<span class="star-gray">★</span>'.repeat(3 - newScore);
      } else {
        document.getElementById('modal-content').classList.add('fail');
        modalStars.innerHTML = '';
      }
      modalOverlay.classList.add('visible');
    }
    modalOverlay.addEventListener('click', () => {
      modalOverlay.classList.remove('visible');
      if (modalOverlay.dataset.resultType === 'success') {
        populateStageSelect(); showScreen('stageSelect');
      } else {
        runButton.disabled = false; resetButton.disabled = false;
      }
    });

    function showTutorial(tutorialData) {
      document.getElementById('tutorial-title').textContent = tutorialData.title;
      document.getElementById('tutorial-text').textContent = tutorialData.text;
      tutorialOverlay.classList.add('visible');
    }

    tutorialButton.addEventListener('click', () => {
      showTutorial(basicTutorial);
    });
    tutorialCloseButton.addEventListener('click', () => {
      tutorialOverlay.classList.remove('visible');
    });


    // --- ゲーム開始時の処理 ---
    populateStageSelect();
    showScreen('title');
  </script>
</body>
</html>

